rm(list = ls())

library(dlnm);library(MASS)

# Loading Data
load("mmt.RData")          
load("2nd_stage.RData")     
load("dlist.RData")         
load("dth_prj.RData")       
load("tmean_prj.RData")     

# Predefining variables
sgg = names(dlist)
temp_types = c('cold', 'heat', 'cs', 'hw')
periods = c('historical', '2021~2040', '2041~2060', '2061~2080', '2081~2100')
adapt_labels = c("no_adapt", "adapt_50%")
adapt_rates = c(0, 0.5)
ci = c("est", "ci.l", "ci.u")
nsim <- 50
dates = seq.Date(as.Date('2011-01-01'), as.Date('2100-12-31'), by = "day")
dates = dates[!(format(dates, "%m-%d") == "02-29")]
dates = dates[format(dates, "%Y") != "2020"]

ansim <- array(NA, 
               dim = c(length(sgg), length(periods), length(temp_types), length(adapt_labels), nsim),
               dimnames = list(sgg, periods, temp_types, adapt_labels, paste0("sim", 1:nsim)))
dth_tot <- matrix(NA, 
                  length(sgg), length(periods), 
                  dimnames = list(sgg, periods))

# Loop
set.seed(1)
pb <- txtProgressBar(min = 0, max = length(sgg), style = 3)
for (i in seq_along(sgg)) {
  setTxtProgressBar(pb, i)
  
  # 1. Loading and merging data
  dat <- as.data.frame(dlist[[i]])
  tmean <- c(dat$tmean, tmean_prj[i,])
  dth   <- c(dat$dth, dth_prj[i,])
  
  # 2. Masking periods
  seqperiod <- matrix(FALSE, length(dates), length(periods), dimnames = list(dates, periods))
  for (p in seq_along(periods)) {
    if (p == 1) {
      from = 1
      to   = 9 * 365
    } else {
      from = (9 + 20 * (p - 2)) * 365 + 1
      to   = (9 + 20 * (p - 1)) * 365
    }
    seqperiod[from:to, p] <- TRUE
  }
  
  # 3. Masking temperature events
  seqtemp = matrix(FALSE, length(dates), length(temp_types), dimnames = list(dates, temp_types))
  seqtemp[,'cold'] <- tmean <= mmt[i]
  seqtemp[,'heat'] <- tmean >  mmt[i]
  seqtemp[,'cs'] <- tmean <  quantile(dat$tmean, 0.025)
  seqtemp[,'hw'] <- tmean >  quantile(dat$tmean, 0.975)
  
  # 4. Defining and scaling the basis
  argvar <- list(fun = "ns", 
                 knots = quantile(dat$tmean, c(0.1, 0.75, 0.9), na.rm = TRUE),
                 Bound = range(dat$tmean, na.rm = TRUE))
  cenvec <- do.call(onebasis, c(list(x = mmt[i]), argvar))
  bvar <- do.call(onebasis, c(list(x = tmean), argvar))
  bvar <- scale(bvar, center = cenvec, scale = FALSE)
  
  # 5. Calculating AF: Monte Carlo
  coefsim <- mvrnorm(nsim, blup[[i]]$blup, blup[[i]]$vcov)
  eta <- bvar %*% t(coefsim)
  af <- 1 - exp(-eta)
  af[af < 0] <- 0 
  
  # 6. Calculating AN: Accounting heat adapation scenarios
  for (ad in seq_along(adapt_rates)) {
    af_adj <- af
    af_adj[seqtemp[,'heat'], ] <- af_adj[seqtemp[,'heat'], ] * (1 - adapt_rates[ad])
    an <- af_adj * dth
    
    # 7. Aggregating results
    for (p in seq_along(periods)) {
      dth_tot[i, p] <- sum(dth[seqperiod[, p]]) / ifelse(p == 1, 9, 20)  # 연평균화
      for (t in seq_along(temp_types)) {
        ansim[i, p, t, ad, ] <- colSums(an[seqtemp[, t] & seqperiod[, p], ]) / ifelse(p == 1, 9, 20)
      }
    }
  }
  
  rm(dat, tmean, dth, seqperiod, seqtemp, argvar, cenvec, bvar, coefsim, eta, af, af_adj, from, to)
  gc()
}

an <- array(NA, 
            dim = c(length(sgg), length(periods), length(ci), length(temp_types), length(adapt_labels)),
            dimnames = list(sgg, periods, ci, temp_types, adapt_labels))
an[,, "est",,] <- apply(ansim, c(1,2,3,4), mean)
an[,, "ci.l",,] <- apply(ansim, c(1,2,3,4), quantile, 0.025)
an[,, "ci.u",,] <- apply(ansim, c(1,2,3,4), quantile, 0.975)
af <- sweep(an, c(1,2), dth_tot, "/")
af <- af * 100  

save(an, af, file = 'results.RData')
